//! Using the SP1 SDK to generate a proof of correct derivation from an espresso block.
//!
//! You can run this script using the following command:
//! ```shell
//! RUST_LOG=info cargo run --package espresso-derivation-prover --bin prove --release
//! ```

// TODO: this crate should take inputs of an espresso block, block header, and other
// information from espresso light client or query service, extract public and private
// inputs for derivation pipeline, and generate need proofs. (Incomplete) workflow:
//  - Program input: espresso block, block header, etc.
//  - Scan through the namespace table for the index of this rollup's namespace ID.
//  - Feed these input to the program to generate a proof.

use clap::Parser;
use committable::Committable;
use espresso_derivation_utils::{
    block::{
        header::{BlockHeader, BlockMerkleTree},
        payload::{rollup_commit, vid_scheme, NsProof, Payload, VidParam},
    },
    ns_table::NsTable,
    PublicInputs,
};
use jf_merkle_tree::{AppendableMerkleTreeScheme, MerkleTreeScheme};
use jf_pcs::prelude::UnivariateUniversalParams;
use jf_vid::{payload_prover::PayloadProver, VidScheme};
use serde::{Deserialize, Serialize};
use sp1_sdk::{HashableKey, ProverClient, SP1PlonkBn254Proof, SP1Stdin, SP1VerifyingKey};
use std::path::PathBuf;

/// The ELF (executable and linkable format) file for the Succinct RISC-V zkVM.
///
/// This file is generated by running `cargo prove build` inside the `program` directory.
pub const ELF: &[u8] = include_bytes!("../../../program/elf/riscv32im-succinct-zkvm-elf");

/// The arguments for the prove command.
// TODO: fill in other details
#[derive(Parser, Debug)]
#[clap(author, version, about, long_about = None)]
struct ProveArgs {
    #[clap(long, default_value = "false")]
    evm: bool,
}

#[allow(dead_code)]
fn parse_bytes(arg: &str) -> Result<NsTable, std::num::ParseIntError> {
    Ok(NsTable {
        bytes: (0..arg.len())
            .step_by(2)
            .map(|i| u8::from_str_radix(&arg[i..i + 2], 16))
            .collect::<Result<Vec<_>, _>>()?,
    })
}

fn mock_inputs(stdin: &mut SP1Stdin) {
    let mut block_merkle_tree = BlockMerkleTree::new(32);
    let num_storage_nodes = 10;

    // Mocking namespace ID
    let ns_id = 29u32;

    // 11 bytes for current namespace
    let ns_range = 0..11;

    // Mocking input for a small payload
    let payload = Payload(vec![1u8; 20]);
    let ns_payload = Payload(vec![1u8; 11]);

    let vid_param = load_srs();
    let mut vid = vid_scheme(num_storage_nodes, &vid_param);

    let vid_disperse = vid.disperse(&payload.0).unwrap();
    let vid_common = vid_disperse.common;
    let vid_commitment = vid_disperse.commit;

    let ns_proof: NsProof = vid.payload_proof(payload.0, ns_range).unwrap();

    // This is a tweak from an actual block header in Espresso's staging testnet
    // Namespace table is hardcoded.
    let mut header: BlockHeader = serde_json::from_str(
        r#"{
            "chain_config": {
                "chain_config": {
                    "Left": {
                        "chain_id": "888888888",
                        "max_block_size": "30000000",
                        "base_fee": "0",
                        "fee_contract": null,
                        "fee_recipient": "0x0000000000000000000000000000000000000000"
                    }
                }
            },
            "height": 69781,
            "timestamp": 1720789795,
            "l1_head": 5113,
            "l1_finalized": {
                "number": 5088,
                "timestamp": "0x669129ec",
                "hash": "0xfc4249b13292d2617cc0dec8b0a9a666491d5fecdfe536c929207847364b2b60"
            },
            "payload_commitment": "HASH~KpvHX4MuDuZKk10QJctEoUj-fump6NIAO8fJ048RwNJo",
            "builder_commitment": "BUILDER_COMMITMENT~tEvs0rxqOiMCvfe2R0omNNaphSlUiEDrb2q0IZpRcgA_",
            "ns_table": {
                "bytes": "AQAAAB0AAAALAAAA"
            },
            "block_merkle_tree_root": "MERKLE_COMM~02gWBSt2tcz9XfOOO6xEVicluWIIP95BW8I11f2graggAAAAAAAAAJUQAQAAAAAAUQ",
            "fee_merkle_tree_root": "MERKLE_COMM~yB4_Aqa35_PoskgTpcCR1oVLh6BUdLHIs7erHKWi-usUAAAAAAAAAAEAAAAAAAAAJg",
            "fee_info": {
                "account": "0x23618e81e3f5cdf7f54c3d65f7fbc0abf5b21e8f",
                "amount": "0"
            },
            "builder_signature": {
                "r": "0x6291b473fdac85b9ce7b40b530ea4173ac6e71fd29acffc3cbc97ae637d4404d",
                "s": "0x3178fe07d5071df7a7ce4106e6e1e3727aa6edc458db03d1774948bdec32eac6",
                "v": 28
            }
         }"#,
    ).unwrap();
    header.payload_commitment = vid_commitment;

    block_merkle_tree.push(header.commit()).unwrap();

    let (_, mt_proof) = block_merkle_tree.lookup(0).expect_ok().unwrap();

    let rollup_txs_comm = rollup_commit(&ns_payload);

    stdin.write(&block_merkle_tree.commitment());
    stdin.write(&header);
    stdin.write(&mt_proof);
    stdin.write(&ns_id);
    stdin.write(&ns_payload);
    stdin.write(&vid_param);
    stdin.write(&vid_common);
    stdin.write(&ns_proof);
    stdin.write(&rollup_txs_comm);
}

fn main() {
    // Setup the logger.
    sp1_sdk::utils::setup_logger();

    // Parse the command line arguments.
    let args = ProveArgs::parse();

    // Setup the prover client.
    let client = ProverClient::new();

    // Setup the program.
    let (pk, vk) = client.setup(ELF);

    // Setup the inputs.;
    let mut stdin = SP1Stdin::new();
    mock_inputs(&mut stdin);

    if args.evm {
        // Generate the proof.
        let proof = client
            .prove_plonk(&pk, stdin)
            .expect("failed to generate proof");
        create_plonk_fixture(&proof, &vk);
    } else {
        // Generate the proof.
        let proof = client.prove(&pk, stdin).expect("failed to generate proof");
        let public_values: PublicInputs =
            bincode::deserialize(proof.public_values.as_slice()).unwrap();
        println!("Public values: {:?}", public_values);

        // Verify the proof.
        client.verify(&proof, &vk).expect("failed to verify proof");
    }
}

/// A fixture that can be used to test the verification of SP1 zkVM proofs inside Solidity.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
struct ProofFixture {
    vkey: String,
    public_values: String,
    proof: String,
}

/// Create a fixture for the given proof.
fn create_plonk_fixture(proof: &SP1PlonkBn254Proof, vk: &SP1VerifyingKey) {
    // Create the testing fixture so we can test things end-to-end.
    let fixture = ProofFixture {
        vkey: vk.bytes32().to_string(),
        public_values: proof.public_values.bytes().to_string(),
        proof: proof.bytes().to_string(),
    };

    // The verification key is used to verify that the proof corresponds to the execution of the
    // program on the given input.
    //
    // Note that the verification key stays the same regardless of the input.
    println!("Verification Key: {}", fixture.vkey);

    // The public values are the values whicha are publicly committed to by the zkVM.
    //
    // If you need to expose the inputs or outputs of your program, you should commit them in
    // the public values.
    println!("Public Values: {}", fixture.public_values);

    // The proof proves to the verifier that the program was executed with some inputs that led to
    // the give public values.
    println!("Proof Bytes: {}", fixture.proof);

    // Save the fixture to a file.
    let fixture_path = PathBuf::from(env!("CARGO_MANIFEST_DIR")).join("../contracts/src/fixtures");
    std::fs::create_dir_all(&fixture_path).expect("failed to create fixture path");
    std::fs::write(
        fixture_path.join("fixture.json"),
        serde_json::to_string_pretty(&fixture).unwrap(),
    )
    .expect("failed to write fixture");
}

fn load_srs() -> VidParam {
    // low degree for demo only
    pub const SRS_DEGREE: usize = 8usize;
    let srs = ark_srs::kzg10::aztec20::setup(SRS_DEGREE).expect("Aztec SRS failed to load");
    VidParam(UnivariateUniversalParams {
        powers_of_g: srs.powers_of_g,
        h: srs.h,
        beta_h: srs.beta_h,
        powers_of_h: vec![srs.h, srs.beta_h],
    })
}
