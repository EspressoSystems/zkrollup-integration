//! Using the SP1 SDK to generate a proof of correct derivation from an espresso block.
//!
//! You can run this script using the following command:
//! ```shell
//! RUST_LOG=info cargo run --package espresso-derivation-prover --bin prove --release
//! ```

// TODO: this crate should take inputs of an espresso block, block header, and other
// information from espresso light client or query service, extract public and private
// inputs for derivation pipeline, and generate need proofs. (Incomplete) workflow:
//  - Program input: espresso block, block header, etc.
//  - Scan through the namespace table for the index of this rollup's namespace ID.
//  - Feed these input to the program to generate a proof.

use clap::Parser;
use committable::Committable;
use espresso_derivation_utils::{
    block::{
        header::{BlockHeader, BlockMerkleTree},
        payload::{rollup_commit, vid_scheme, NsProof, Payload, VidParam},
    },
    ns_table::NsTable,
    PublicInputs,
};
use jf_merkle_tree::{AppendableMerkleTreeScheme, MerkleTreeScheme};
use jf_pcs::prelude::UnivariateUniversalParams;
use jf_vid::{payload_prover::PayloadProver, VidScheme};
use serde::{Deserialize, Serialize};
use sp1_sdk::{HashableKey, ProverClient, SP1PlonkBn254Proof, SP1Stdin, SP1VerifyingKey};
use std::path::PathBuf;

/// The ELF (executable and linkable format) file for the Succinct RISC-V zkVM.
///
/// This file is generated by running `cargo prove build` inside the `program` directory.
pub const ELF: &[u8] = include_bytes!("../../../../elf/riscv32im-succinct-zkvm-elf");

/// The arguments for the prove command.
// TODO: fill in other details
#[derive(Parser, Debug)]
#[clap(author, version, about, long_about = None)]
struct ProveArgs {
    // #[clap(long, default_value = "29")]
    // ns_id: u32,

    // #[clap(long, value_parser = parse_bytes, default_value = "010000001D0000000B000000")]
    // ns_table: NsTable,

    // #[clap(long, default_value = "0")]
    // ns_index: u32,

    // #[clap(long, default_value = "0")]
    // ns_range_start: u32,

    // #[clap(long, default_value = "11")]
    // ns_range_end: u32,
    #[clap(long, default_value = "false")]
    evm: bool,
}

fn parse_bytes(arg: &str) -> Result<NsTable, std::num::ParseIntError> {
    Ok(NsTable(
        (0..arg.len())
            .step_by(2)
            .map(|i| u8::from_str_radix(&arg[i..i + 2], 16))
            .collect::<Result<Vec<_>, _>>()?,
    ))
}

fn mock_inputs(stdin: &mut SP1Stdin) {
    let mut block_merkle_tree = BlockMerkleTree::new(32);
    let num_storage_nodes = 10;

    let ns_range = 0..11;

    let payload = Payload(vec![0u8; 20]);
    let ns_payload = Payload(vec![0u8; 11]);

    let vid_param = load_srs();
    let mut vid = vid_scheme(num_storage_nodes, &vid_param);

    let vid_disperse = vid.disperse(&payload.0).unwrap();
    let vid_common = vid_disperse.common;
    let vid_commitment = vid_disperse.commit;

    let ns_proof: NsProof = vid.payload_proof(payload.0, ns_range).unwrap();

    let header = BlockHeader {
        chain_config: Default::default(),
        height: 10,
        timestamp: 10,
        l1_head: 10,
        l1_finalized: None,
        payload_commitment: vid_commitment,
        builder_commitment: [0u8; 32],
        ns_table: parse_bytes("010000001D0000000B000000").unwrap(),
        block_merkle_tree_root: block_merkle_tree.commitment(),
        fee_merkle_tree_root: vec![0u8; 32],
        fee_info: Default::default(),
    };
    block_merkle_tree.push(header.commit()).unwrap();

    let (_, mt_proof) = block_merkle_tree.lookup(0).expect_ok().unwrap();

    let ns_id = 29u32;

    let rollup_txs_comm = rollup_commit(&ns_payload);

    stdin.write(&block_merkle_tree.commitment());
    stdin.write(&header);
    stdin.write(&mt_proof);
    stdin.write(&ns_id);
    stdin.write(&ns_payload);
    stdin.write(&vid_param);
    stdin.write(&vid_common);
    stdin.write(&ns_proof);
    stdin.write(&rollup_txs_comm);
}

fn main() {
    // Setup the logger.
    sp1_sdk::utils::setup_logger();

    // Parse the command line arguments.
    let args = ProveArgs::parse();

    // Setup the prover client.
    let client = ProverClient::new();

    // Setup the program.
    let (pk, vk) = client.setup(ELF);

    // Setup the inputs.;
    let mut stdin = SP1Stdin::new();
    mock_inputs(&mut stdin);

    if args.evm {
        // Generate the proof.
        let proof = client
            .prove_plonk(&pk, stdin)
            .expect("failed to generate proof");
        create_plonk_fixture(&proof, &vk);
    } else {
        // Generate the proof.
        let proof = client.prove(&pk, stdin).expect("failed to generate proof");
        let public_values: PublicInputs =
            bincode::deserialize(proof.public_values.as_slice()).unwrap();
        println!("Public values: {:?}", public_values);

        // Verify the proof.
        client.verify(&proof, &vk).expect("failed to verify proof");
    }
}

/// A fixture that can be used to test the verification of SP1 zkVM proofs inside Solidity.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
struct ProofFixture {
    vkey: String,
    public_values: String,
    proof: String,
}

/// Create a fixture for the given proof.
fn create_plonk_fixture(proof: &SP1PlonkBn254Proof, vk: &SP1VerifyingKey) {
    // Create the testing fixture so we can test things end-to-end.
    let fixture = ProofFixture {
        vkey: vk.bytes32().to_string(),
        public_values: proof.public_values.bytes().to_string(),
        proof: proof.bytes().to_string(),
    };

    // The verification key is used to verify that the proof corresponds to the execution of the
    // program on the given input.
    //
    // Note that the verification key stays the same regardless of the input.
    println!("Verification Key: {}", fixture.vkey);

    // The public values are the values whicha are publicly committed to by the zkVM.
    //
    // If you need to expose the inputs or outputs of your program, you should commit them in
    // the public values.
    println!("Public Values: {}", fixture.public_values);

    // The proof proves to the verifier that the program was executed with some inputs that led to
    // the give public values.
    println!("Proof Bytes: {}", fixture.proof);

    // Save the fixture to a file.
    let fixture_path = PathBuf::from(env!("CARGO_MANIFEST_DIR")).join("../contracts/src/fixtures");
    std::fs::create_dir_all(&fixture_path).expect("failed to create fixture path");
    std::fs::write(
        fixture_path.join("fixture.json"),
        serde_json::to_string_pretty(&fixture).unwrap(),
    )
    .expect("failed to write fixture");
}

fn load_srs() -> VidParam {
    // low degree for demo only
    pub const SRS_DEGREE: usize = 1024usize;
    let srs = ark_srs::kzg10::aztec20::setup(SRS_DEGREE).expect("Aztec SRS failed to load");
    VidParam(UnivariateUniversalParams {
        powers_of_g: srs.powers_of_g,
        h: srs.h,
        beta_h: srs.beta_h,
        powers_of_h: vec![srs.h, srs.beta_h],
    })
}
